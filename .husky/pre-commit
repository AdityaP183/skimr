#!/bin/sh
# Exit on any error
set -e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)

# Create a temporary file to store staged file list
TEMP_FILE=$(mktemp)
echo "$STAGED_FILES" > "$TEMP_FILE"

# Run formatter on the staged files
pnpm dlx ultracite fix
FORMAT_EXIT_CODE=$?

# Handle formatter failure
if [ $FORMAT_EXIT_CODE -ne 0 ]; then
  echo "❌ Formatting failed. Commit aborted."
  rm -f "$TEMP_FILE"
  exit $FORMAT_EXIT_CODE
fi

# Re-stage all the files that were originally staged
# This will include any modifications made by the formatter
while IFS= read -r file; do
  if [ -f "$file" ]; then
    git add "$file"
  fi
done < "$TEMP_FILE"

# Clean up temp file
rm -f "$TEMP_FILE"

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "✨ Files formatted and added to commit"
fi

exit 0
